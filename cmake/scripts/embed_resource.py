#!/usr/bin/env python3
"""Generate C++ header with embedded file contents as byte arrays.

Usage: embed_resource.py <output> <varname1>=<file1> [<varname2>=<file2> ...]

Outputs a header with:
  inline constexpr unsigned char kVarName[] = { 0x00, ... };
  inline constexpr size_t kVarNameSize = 123;
"""

import argparse
import sys
from pathlib import Path


def to_pascal_case(name: str) -> str:
    """Convert snake_case to PascalCase."""
    return "".join(word.capitalize() for word in name.split("_"))


def format_bytes(data: bytes) -> str:
    """Format bytes as C++ array initializer."""
    lines = []
    line = ""
    for i, b in enumerate(data):
        chunk = f"0x{b:02x}"
        if i < len(data) - 1:
            chunk += ", "
        if len(line) + len(chunk) > 90:
            lines.append(line)
            line = chunk
        else:
            line += chunk
    if line:
        lines.append(line)
    return "\n    ".join(lines)


def generate_resource(varname: str, data: bytes) -> str:
    pascal = to_pascal_case(varname)
    array_content = format_bytes(data)

    return f"""inline constexpr unsigned char k{pascal}[] = {{
    {array_content}
}};
inline constexpr size_t k{pascal}Size = {len(data)};
"""


def main() -> int:
    parser = argparse.ArgumentParser(description="Embed files as C++ byte arrays")
    parser.add_argument("output", help="Output header path")
    parser.add_argument(
        "resources",
        nargs="+",
        metavar="VAR=FILE",
        help="Variable name and file path pairs",
    )
    args = parser.parse_args()

    output_path = Path(args.output)

    # Parse var=file pairs
    resources = []
    for res in args.resources:
        if "=" not in res:
            print(
                f"Error: invalid resource format '{res}', expected VAR=FILE",
                file=sys.stderr,
            )
            return 1
        varname, filepath = res.split("=", 1)
        resources.append((varname, Path(filepath)))

    # Generate header
    header_parts = [
        "// Auto-generated by embed_resource.py - DO NOT EDIT",
        "#pragma once",
        "",
        "#include <cstddef>",
        "",
        "namespace envy::embedded {",
        "",
    ]

    for varname, filepath in resources:
        if not filepath.exists():
            print(f"Error: file not found: {filepath}", file=sys.stderr)
            return 1

        data = filepath.read_bytes()
        header_parts.append(generate_resource(varname, data))

    header_parts.append("}  // namespace envy::embedded")
    header_parts.append("")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(header_parts))

    return 0


if __name__ == "__main__":
    sys.exit(main())
