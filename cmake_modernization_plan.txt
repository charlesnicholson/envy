Multi-step plan to simplify and modernize CMake (minimum version 4.1.2)

1. Preserve the constrained configuration surface
   - Re-audit `CMakeLists.txt` and `cmake/Dependencies.cmake` after every dependency change to ensure the only cache knobs exposed to users remain `CMAKE_BUILD_TYPE` and `ENABLE_LTO`.
   - Keep third-party toggles hard-coded (tests/examples off, static builds on) and document these invariants inline so they stay aligned with AGENTS.md.
   - Carry the same contract into contributor docs (`docs/dependencies.md`, `README.md`) so future refactors understand the single supported build path.

2. Harden the dependency version catalog
   - Expand the new catalog at the top of `cmake/Dependencies.cmake` into the source of truth for every URL, archive, and checksum.
   - Add a lightweight lint (e.g., CMake option or scripting) that fails configure when a dependency block lacks catalog coverage, keeping ad-hoc literals from creeping back in.
   - Mirror significant bumps in `docs/dependencies.md` so release notes and automation can diff versions easily.

3. Tame FetchContent plumbing without losing caching guarantees
   - Evaluate replacing `codex_fetchcontent_populate` with `FetchContent_MakeAvailable()` only if we can preserve the cached source layout under `out/cache/third_party` and the disconnected/offline workflows.
   - Where direct substitution is impractical, encapsulate repeated patch/setup logic in helper modules under `cmake/` rather than open-coding edits inside the main dependency file.
   - Normalize patch application (libssh2/libarchive/custom scripts) through `file(CONFIGURE)` + stamp files so configure traces remain deterministic on reconfigure.

4. Rationalize aggregate target wiring
   - Revisit `codex::thirdparty` and ensure every dependency is expressed via `target_link_libraries(... INTERFACE ...)`, letting CMake infer the build graph instead of manual `add_dependencies` chains.
   - Move platform-specific framework links behind generator expressions on the same target to keep logic declarative.
   - Remove any leftover cache pokes (`set(CURL_INCLUDE_DIR ...)`, etc.) once upstream targets propagate includes correctly.

5. Improve developer UX within the existing workflow
   - Keep `./build.sh` as the primary entrypoint but consider layering optional `CMakePresets.json` that simply call into the script, so IDEs and CLI users share the same configuration recipe.
   - Capture any new workflow expectations in `AGENTS.md` and the README, ensuring instructions stay consistent across automation and human contributors.
   - If cross-compilation becomes necessary, introduce toolchain files under `cmake/toolchains/` with the same caching model rather than separate ad-hoc instructions.

6. Validation and migration
   - After each modernization milestone, reconfigure from a clean tree and run `./build.sh` to validate the static driver and third-party projects.
   - Track changes in a short `docs/modernizing-cmake.md` note so downstream automation and agents understand the rollout timeline and required adjustments.
